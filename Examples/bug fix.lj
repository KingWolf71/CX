/* Bug Fix Test
*/

#pragma appname "Bug Fix"
#pragma decimals 3
#pragma console on
#pragma consolesize "560x590"
#pragma consoleposition "30,50"
#pragma optimizecode on
#pragma ListASM on
#pragma FastPrint on
#pragma RunThreaded on
#pragma ftoi "truncate"
#pragma version on
#pragma modulename on
#pragma PasteToClipboard on
#pragma floattolerance 0.001
#pragma stackspace 64000
#pragma stackdepth 64000
#pragma DumpASM on

#define		ELEMENTS 100
//#define		ELEMENTS 200

// === Test 10: Functions Returning Array Values ===
print("Test 10: Functions Returning Array Values");

function getArraySum() {
    array nums.i[3];
    nums[0] = 5;
    nums[1] = 10;
    nums[2] = 15;

    total = nums[0] + nums[1] + nums[2];
    print("  Array sum in function = ", total);
    return total;
}

returnedSum = getArraySum();
print("  Returned sum = ", returnedSum);
assertEqual(30, returnedSum);

function getArrayElement() {
    array data.i[4];
    data[0] = 100;
    data[1] = 200;
    data[2] = 300;
    data[3] = 400;

    return data[2];
}

element = getArrayElement();
print("  Returned element = ", element);
assertEqual(300, element);

function computeWithArrays() {
    array a.i[2];
    array b.i[2];

    a[0] = 10;
    a[1] = 20;
    b[0] = 5;
    b[1] = 3;

    result = (a[0] + a[1]) * (b[0] - b[1]);
    print("  Computed result = ", result);
    return result;
}

computed = computeWithArrays();
print("  Final computed value = ", computed);
assertEqual(60, computed);
print("  PASS: Functions returning array values");
print("");


// === Test 11: Nested Function Calls ===
print("Test 11: Nested Function Calls");

function helper1() {
    array h1_array.i[2];
    h1_array[0] = 10;
    h1_array[1] = 20;
    result = h1_array[0] + h1_array[1];
    print("  helper1 result = ", result);
    return result;
}

function helper2() {
    array h2_array.i[2];
    h2_array[0] = 5;
    h2_array[1] = 15;
    val = helper1();
    result = h2_array[0] + h2_array[1] + val;
    print("  helper2 result = ", result);
    return result;
}

final = helper2();
print("  Final result = ", final);
assertEqual(50, final);
print("  PASS: Nested function calls with local arrays");
print("");


print("=================================");
print("Array Sort Stress Test");
print(ELEMENTS, " float elements - Quicksort");
print("=================================");
print("");

// Declare array of ELEMENTS floats

array data.f[ELEMENTS];

// Fill array with random values 
print("Filling array with ",  ELEMENTS," random values...");
i = 0;
rnd.f = 0.0;

while (i < ELEMENTS) {
	rnd = (random(1000, 40000000) + 0.1 )/ random(500,257733);
    data[i] = rnd;
    i++;
}

print("Array filled.");
print("");

// Print first few elements before sort
print("Before sort - first 10 elements:");
print("  data[0] = ", data[0]);
print("  data[1] = ", data[1]);
print("  data[2] = ", data[2]);
print("  data[9] = ", data[9]);
print("");

// Quicksort implementation
function quicksort(arr_slot, left, right) {
    if (left < right) {
        // Partition
        pivot_idx = partition(arr_slot, left, right);

        // Recursively sort left and right partitions
        quicksort(arr_slot, left, pivot_idx - 1);
        quicksort(arr_slot, pivot_idx + 1, right);
    }
}

function partition(arr_slot, left, right) {
    // Use rightmost element as pivot
    // V1.022.71: Type annotation (.f) creates local automatically - shadows global 'i'
    pivot.f = data[right];
    i.i = left - 1;    // Type annotation = local (shadows global i)

    j.i = left;        // Type annotation = local
    while (j < right) {
        if (data[j] <= pivot) {
            i++;
            // Swap data[i] and data[j]
            temp.f = data[i];  // Type annotation = local
            data[i] = data[j];
            data[j] = temp;
        }
        j++;
    }

    // Place pivot in correct position
    i++;
    temp2.f = data[i];  // Type annotation = local
    data[i] = data[right];
    data[right] = temp2;

    return i;
}

// Sort the array
print("Sorting array using quicksort...");
quicksort(0, 0, (ELEMENTS - 1) );
print("Sort complete!");
print("");

// Print after sort - first few elements
print("After sort - first 10 elements:");
print("  data[0] = ", data[0]);
print("  data[1] = ", data[1]);
print("  data[2] = ", data[2]);
print("  data[9] = ", data[9]);
print("");

// Print every 100th element to verify sort
print("Every 100th element (should be ascending):");
print("=================================");
i = 0;
while (i < ELEMENTS) {
    print("  data[", i, "] = ", data[i]);
    i = i + 100;
}
print("=================================");
print("");

// Verify sorted order
print("Verifying array is sorted...");
i = 0;
errors = 0;
while (i < (ELEMENTS - 1)) {
    if (data[i] > data[i + 1]) {
        print("ERROR: data[", i, "] = ", data[i], " > data[", i + 1, "] = ", data[i + 1]);
        errors = errors + 1;
    }
    i = i + 1;
}

if (errors == 0) {
    print("PASS: All ", ELEMENTS - 1, " adjacent pairs are in correct order!");
} else {
    print("FAIL: Found ", errors, " pairs out of order");
}
print("");

// Performance summary
print("=================================");
print("Stress Test Complete!");
print("Array size: ", ELEMENTS, " elements");
print("Total comparisons: ~O(n log n)");
print("Specialized opcodes used:");
print("  - ARRFETCH_FLT_G_OPT");
print("  - ARRSTORE_FLT_G_OPT_OPT");
print("  - ARRSTORE_FLT_G_OPT_STACK");
print("=================================");